# -*- coding: utf-8 -*-
"""MancalaProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kjyRt39eUam-ka4K8fFozvHIOfRM3SGj

# **DSCC 442 Project 2: Mancala**
# Brooke Brehm and Ky Potter
"""

import copy
import numpy as np
import random
import time

def minimax(k_node, p_num, depth=3, max_player=True):
  # Outputs the best move as at a depth of 3 as determined by alternating minimizing and maximizing player
  if p_num==2:
    index = 3
    player=1
  if p_num == 1:
    index = 0
    player=2
  if depth==0 or sum(k_node.state[1])==0 or sum(k_node.state[2])==0:
      return k_node
  if max_player: # if maximizing
        best=-999
        for m in movement(k_node, p_num):
          val=minimax(m, p_num, depth-1, max_player=False)
          if best==-999:
            if val.state[index][0]>best:
                best=m
          else:
            if val.state[index][0]>best.state[index][0]:
                best=m
        return best
  else: # if minimizing 
        best=999
        for m in movement(k_node, p_num):
          val=minimax(m, p_num, depth-1, max_player=True)
          if best==999:
            if val.state[index][0]<best:
                best=m
          else:
            if val.state[index][0]<best.state[index][0]:
                best=m
        return best

def alphabeta(k_node, p_num, depth, alpha=-999, beta=999, max_player=True):
  # altered minimax to incorporate alpha and beta pruning
  # should output best move
  if p_num==2:
    index = 3
    player=1
  if p_num == 1:
    index = 0
    player=2
  if depth==0 or sum(k_node.state[1])==0 or sum(k_node.state[2])==0:
      return k_node
  if max_player:
        best=-999
        for m in movement(k_node, p_num):
          val=alphabeta(m, p_num, depth-1, alpha, beta, max_player=False)
          if best==-999:
            if val.state[index][0]>best:
                best=m
            if val.state[index][0]>alpha:
                  alpha=val.state[index][0]
            if alpha>=beta:
                  continue
          else:
            if val.state[index][0]>best.state[index][0]:
                best=m
            if val.state[index][0]>alpha:
                  alpha=val.state[index][0]
            if alpha>=beta:
                  continue
        return best
  else:
        best=999
        for m in movement(k_node, p_num):
          val=alphabeta(m, p_num, depth-1, alpha, beta, max_player=True)
          if best==999:
            if val.state[index][0]<best:
                best=m
            if val.state[index][0]<beta:
              beta=val.state[index][0]
            if beta<=alpha:
              continue
          else:
            if val.state[index][0]<best.state[index][0]:
                best=m
            if val.state[index][0]<beta:
              beta=val.state[index][0]
            if beta<=alpha:
              continue
        return best

class m_node:
  def __init__(self, state1):
    self.state = state1
    self.parent = None
    self.children = []

  # Board representation is a repr created from the state.
  # Player 2 pits iterated normally and reversed for the board.
  def __repr__(self):
    board = "\n" + str(self.state[0]) + str(self.state[1][::-1]) + "    " + "\n" + '   ' + str(self.state[2]) + str(self.state[3]) + "\n"
    return board

def print_movement(k_node, new_k_node):
  path=[]
  if new_k_node.parent!=k_node:
    work=copy.deepcopy(new_k_node.parent)
    path.append(work)
    print_movement(k_node,new_k_node.parent)
    for i in range(len(path)):
      print(path[i])
  else:
    return

# This section is creating all of the player classes so that player 1 & 2 moves 
# can be run as .move() in the check_players function.
class human():
  def __init__(self, p_number):
    self.p_num = p_number

  def move(self, k_node):
    start=time.time()
    print(f'Human Turn') #, Time Taken: {end-start}')
    k_node, win = human_input(k_node, self.p_num)
    end=time.time()
    print(k_node)
    return k_node, win


class ran_play():
  def __init__(self, p_number):
    self.p_num = p_number

  # pick random move, check if valid (looping function), then use random move function
  # print, then check win state, return node with final state and whether someone has won
  def move(self, k_node):
    start=time.time()
    k_node, win = random_input(k_node, self.p_num)
    end=time.time()
    # print(f'Random Turn, Time Taken: {end-start}')
    print(k_node)
    return k_node, win


class min_max():
  def __init__(self, p_number):
    self.p_num = p_number

  # run the minimax function on the node to choose the best move, play it, and check win state
  def move(self, k_node):
    start=time.time()
    new_k_node= minimax(k_node, self.p_num, depth=3)
    end=time.time()
    new_k_node, win = check_win(new_k_node)
    print(f'Minimax Turn') #, Time Taken: {end-start}')
    print_movement(k_node, new_k_node)
    if win!=True:
        print(new_k_node) 
    return new_k_node, win


class a_b():
  def __init__(self, p_number):
    self.p_num = p_number
  # run the alphabeta function on the node to choose the best move, play it, and check win state
  def move(self, k_node):
    start=time.time()
    new_k_node=alphabeta(k_node, self.p_num, depth=3, alpha=-999, beta=999, max_player=True)
    end=time.time()
    new_k_node, win = check_win(new_k_node)
    print(f'Alphabeta Turn') #, Time Taken: {end-start}')
    print_movement(k_node, new_k_node)
    if win!=True:
        print(new_k_node) 
    return new_k_node, win

# Creates initial board of Player 2 store and pits and player 1 pits and store.
# [ [P2 store], [P2 pits], [P1 pits], [P1 store] ]
# This seemed easiest for updating moves moving counterclockwise.
# k = number of stones, m = number of pits
def init_state(k, m):
  state = []
  # For floats, this gives the floor. EX: m of 13 gives 6 pits.
  p_board = int(m/2)
  # Player board "facing" you (the user), also goes first.
  p1 = [k]*p_board
  # Player board opposite of you (the user), also goes second.
  p2 = [k]*p_board
  state.append([0])
  state.append(p2)
  state.append(p1)
  state.append([0])
  return state

# In the movement functions, after children are generated check to see if 
# the board state is terminal. Update the board.
def check_win(kalah_node):
  # print(kalah_node)
  pits = len(kalah_node.state[1])
  win = False
    # If one side of pits is empty, all remaining stones on the other side go
    # into that side's store.
    # No stones left in P2's pits. Add all stones in P1's pits to P1 store.
  if sum(kalah_node.state[1]) == 0:
    win = True
    kalah_node.state[3][0] += sum(kalah_node.state[2])
    kalah_node.state[2] = [0]*pits
    # No stones left in P1's pits. Add all stones in P2's pits to P2 store.
  elif sum(kalah_node.state[2]) == 0:
    win = True
    kalah_node.state[0][0] += sum(kalah_node.state[1])
    kalah_node.state[1] = [0]*pits
    # Update board representation at end of each move.
    # kalah_node.board = board_rep(kalah_node)
  return kalah_node, win

# Takes in the node which will become our parent node, player (1 or 2).
def movement(kalah_node, player_index):
  
  child_list = []

  # Go through each of the pits on current player's side of the board.
  for i in range(len(kalah_node.state[player_index])):
    # skip if pit is empty
    if kalah_node.state[player_index][i] == 0:
      continue
    c_list = getStates(kalah_node, player_index, i)
    child_list = child_list + c_list
  
  # We'll want to add the child to the node after minimax decides the best move.
  # Returns list of child nodes. 
  # In minimax, should be able to use (Player 2) sum(child.state[0]) and
  # (Player 1) sum(child.state[3]) for scores.
  return child_list

def getStates(kalah_node, side, pit_index):
  child_list = []
  cur_pit = pit_index
  n_stones = kalah_node.state[side][pit_index]
  c_state = copy.deepcopy(kalah_node.state)
  c_node = m_node(c_state)
  c_node.parent = kalah_node
  c_node.state[side][pit_index] = 0
  cur_side = side

  while (n_stones > 0):
    cur_pit += 1
    if (cur_pit < len(c_node.state[cur_side])):
      # If there is only 1 stone to be dropped off.
      if n_stones == 1:
        # If the current side is the player's side and current pit is empty.
        if (cur_side == side) and c_node.state[cur_side][cur_pit]== 0: #sum(c_node.state[cur_side][cur_pit]) == 0:
          # Get the index of the pit across from the player's empty one.
          opposite = len(c_node.state[cur_side]) - (cur_pit + 1)
          
          # Add the stones from the opposite pit and the player's last stone to the player's store.
          # Empty the opposite pit.
          if side == 1:
            if c_node.state[2][opposite] != 0:
              c_node.state[0][0] += 1
              c_node.state[0][0] += c_node.state[2][opposite]#sum(c_node.state[2][opposite])
              c_node.state[2][opposite] = 0
            else:
              c_node.state[cur_side][cur_pit] += 1
          
          if side == 2:
            if c_node.state[1][opposite] != 0:
              c_node.state[3][0] += 1
              c_node.state[3][0] += c_node.state[1][opposite]#sum(c_node.state[1][opposite])
              c_node.state[1][opposite] = 0
            else:
              c_node.state[cur_side][cur_pit] += 1
        # If the current side is not the player's/not empty just drop the stone in the current pit.
        else:
          c_node.state[cur_side][cur_pit] += 1
      # Otherwise just drop the stone in the current pit.
      else:
        c_node.state[cur_side][cur_pit] += 1
      # Lower the number of stones "in hand" by one. This is for both scenarios.
      n_stones -= 1
    else:
      # Swap sides at beginning of next while loop (will be in pit index 0).
      cur_pit = -1
      # If the current side is the player's side, drop pit in store.
      # If no stones left after store, loop will finish. 
      # cur_pit of -1 outside of loop means more moves in current turn.
      # if cur_side == side:
      #   n_stones -= 1
      #   if side == 2:
      #     c_node.state[3][0] += 1
      #   # changed from else
      #   elif side == 1:
      #     c_node.state[0][0] += 1

      if cur_side == 2 and side == 2:
        c_node.state[3][0] += 1
        n_stones -= 1
      elif cur_side == 1 and side == 1:
        c_node.state[0][0] += 1
        n_stones -= 1

      # Swapping which side of the board we're on if we've run out of pits on current side.
      if (cur_side == 1):
        cur_side = 2
      else:
        cur_side = 1
      
  # Check if move put the board in a terminal state and add scores if yes.
  c_node, win = check_win(c_node)


  if cur_pit == -1 and win == False:
    for i in range(len(c_node.state[side])):
      if (c_node.state[side][i] == 0):
        continue
      c_list = getStates(c_node,side,i)
      child_list = child_list + c_list
  else:
    child_list.append(c_node)
    

  return child_list

def human_move(kalah_node, side, pit_num, human):
  cur_pit = pit_num
  n_stones = kalah_node.state[side][pit_num]
  c_state = copy.deepcopy(kalah_node.state)
  c_node = m_node(c_state)
  c_node.parent = kalah_node
  c_node.state[side][pit_num] = 0
  cur_side = copy.deepcopy(side)
  kalah_node.children.append(c_node)

  while (n_stones > 0):
    cur_pit += 1
    if (cur_pit < len(c_node.state[cur_side])):
      # If there is only 1 stone to be dropped off.
      if n_stones == 1:
        # If the current side is the player's side and current pit is empty.
        if (cur_side == side) and (c_node.state[cur_side][cur_pit] == 0):
          # Get the index of the pit across from the player's empty one.
          opposite = len(c_node.state[cur_side]) - (cur_pit + 1)
          # Add the stones from the opposite pit and the player's last stone to the player's store.
          # Empty the opposite pit.
          if side == 1:
            if c_node.state[2][opposite] != 0:
              c_node.state[0][0] += 1
              c_node.state[0][0] += c_node.state[2][opposite]
              c_node.state[2][opposite] = 0
            else:
              c_node.state[cur_side][cur_pit] += 1
          if side == 2:
            if c_node.state[1][opposite] != 0:
              c_node.state[3][0] += 1
              c_node.state[3][0] += c_node.state[1][opposite]
              c_node.state[1][opposite] = 0
            else:
              c_node.state[cur_side][cur_pit] += 1
        # If the current side is not the player's/not empty just drop the stone in the current pit.
        else:
          c_node.state[cur_side][cur_pit] += 1
      # Otherwise just drop the stone in the current pit.
      else:
        c_node.state[cur_side][cur_pit] += 1
      # Lower the number of stones "in hand" by one. This is for both scenarios.
      n_stones -= 1
    else:
      # Swap sides at beginning of next while loop (will be in pit index 0).
      cur_pit = -1
      # If the current side is the player's side, drop pit in store.
      # If no stones left after store, loop will finish. 
      # cur_pit of -1 outside of loop means more moves in current turn.
      if cur_side == side:
        n_stones -= 1
        if side == 2:
          c_node.state[3][0] += 1
        # changed from else
        elif side == 1:
          c_node.state[0][0] += 1

      # Swapping which side of the board we're on if we've run out of pits on current side.
      if (cur_side == 1):
        cur_side = 2
      else:
        cur_side = 1

  # print(c_node)
  # Check if move put the board in a terminal state and add scores if yes.
  c_node, win = check_win(c_node)

  # If last stone dropped into player's store, ask to move again.
  if cur_pit == -1 and win == False:
    print(c_node)
    if human == True:
      c_node, win = human_input(c_node, side)
    else:
      c_node, win = random_input(c_node, side)


  return c_node, win

def human_input(k_node, player_num):
  human = True
  try:
    p_move = int(input("Which pit are you playing? "))
  except ValueError:
    p_move = 6
  p_move = check_valid(k_node, player_num, p_move)
  k_node, win = human_move(k_node, player_num, p_move, human)
  # k_node, win = check_win(k_node)

  return k_node, win

def random_input(k_node, player_num):
  human = False
  rand_move = random.randrange(len(k_node.state[player_num]))
  if k_node.state[player_num][rand_move] == 0:
    while k_node.state[player_num][rand_move] == 0:
      rand_move = random.randrange(len(k_node.state[player_num]))
  print('Random Move')
  # start=time.time()
  k_node, win = human_move(k_node, player_num, rand_move, human)
  # end=time.time()
  # print(k_node)
  #print(f'Time Taken: {end-start}')
  return k_node, win

def check_valid(kalah_node, player_num, pit_num):
  p1_move = pit_num
  try:
    while p1_move not in [0, 1, 2, 3, 4, 5]:
      print("Please enter a valid move.")
      p1_move = int(input("Which pit (from 0 to 5) are you playing? "))
  except ValueError:
    while p1_move not in [0, 1, 2, 3, 4, 5]:
      print("Please enter a valid move.")
      p1_move = int(input("Which pit (from 0 to 5) are you playing? "))
  if kalah_node.state[player_num][p1_move] == 0:
    while kalah_node.state[player_num][p1_move] == 0:
      print("Please enter a valid move.")
      p1_move = int(input("Which pit (from 0 to 5) are you playing? "))
  
  return p1_move

def check_players(player1, player2, start_node):
  p1_num = 2
  p2_num = 1
  k_node, win= check_win(start_node)

  # First check who is playing and assign variables.
  if player1 == 'human':
      p1 = human(p1_num)
      if player2 == 'human':
        p2 = human(p2_num)
      if player2 == 'random':
        p2 = ran_play(p2_num)
      if player2 == 'minimax':
        p2 = min_max(p2_num)
      if player2 == 'alphabeta':
        p2 = a_b(p2_num)


  if player1 == 'random':
        p1 = ran_play(p1_num)
        if player2 == 'human':
         p2 = human(p2_num)
        if player2 == 'random':
          p2 = ran_play(p2_num)
        if player2 == 'minimax':
          p2 = min_max(p2_num)
        if player2 == 'alphabeta':
          p2 = a_b(p2_num)

  if player1 == 'minimax':
        p1 = min_max(p1_num)
        if player2 == 'human':
          p2 = human(p2_num)
        if player2 == 'random':
          p2 = ran_play(p2_num)
        if player2 == 'minimax':
          p2 = min_max(p2_num)
        if player2 == 'alphabeta':
          p2 = a_b(p2_num)

  if player1 == 'alphabeta':
      p1 = a_b(p1_num)
      if player2 == 'human':
        p2 = human(p2_num)
      if player2 == 'random':
        p2 = ran_play(p2_num)
      if player2 == 'minimax':
        p2 = min_max(p2_num)
      if player2 == 'alphabeta':
        p2 = a_b(p2_num)

        
  while win == False:
    k_node, win=p1.move(k_node)
    if win == True:
      break
    k_node, win= p2.move(k_node)
    if win ==True:
      break
      
  # Once we hit the win state, we'll want to print again to show the final scores.
  # Then we'll declare the winner and end the program.
  # removed sum
  print(k_node)
  #if sum(k_node.state[3]) > sum(k_node.state[0]):
  if k_node.state[3] > k_node.state[0]:
    print("Player 1 is the winner!")
  elif k_node.state[3] < k_node.state[0]:
    print("Player 2 is the winner!")
  elif k_node.state[3] == k_node.state[0]:
    print("Draw!")

  # quit()

def main():
  print("Welcome. Let's play Mancala.")
  print("The board is set to face Player 1 with pits 0 to 5 left to right, and their store on the right.")
  print("Player 2's side is set up across from Player 1, so it works like a mirror image or 180 degree rotation.")
  print("Stones move through pits and stores in a counterclockwise direction starting at player 1's pit 0 (farthest right on the bottom row).")
  print("Please enter number values as integers and options without capitals, punctuation, or quotations.")
  # print("Note: a common board has 12 pits and 4 stones in each pit.")
  # m = int(input("What is the size of the board you would like to use? "))
  # k = int(input("How many stones would you like to place in each pit? "))
  m = 12
  k = 4
  try:
    print("Player options are: minimax, alphabeta, human, random.")
    player1 = input("From the options, who is Player 1 (moves first)? ")
    player2 = input("From the options, who is Player 2? ")
    start_state = init_state(k, m)
    start_node = m_node(start_state)
    print(start_node)
    check_players(player1, player2, start_node)
  except UnboundLocalError:
    print("Entry not valid.")
    print("Please enter a player option with no additional characters or capitalization.")
    print("Player options are: minimax, alphabeta, human, random.")
    player1 = input("From the options, who is Player 1 (moves first)? ")
    player2 = input("From the options, who is Player 2? ")
    start_state = init_state(k, m)
    start_node = m_node(start_state)
    print(start_node)
    check_players(player1, player2, start_node)

if __name__ == '__main__':
  main()
